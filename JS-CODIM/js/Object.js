// https://learn.javascript.ru/object


let min = 0;
let max = 49;
var summaArr = 0;
const arr = [];
for (i = 0; i < 10; i++) {
    function randomNumberGeneration(min, max) {
        return number = Math.floor(min + Math.random() * (max + 1 - min));
    }
    randomNumberGeneration(min, max);
    arr[i] = number;
}


// Пустой объект может быть создан одним из двух синтаксисов:
myObject = new Object();
myObject = {};

var person = {}; // пока пустой
/* при присвоении свойства в объекте автоматически создаётся "ящик"
с именем "name" и в него записывается содержимое 'Вася' */
person.name = 'Вася';
person.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25
/* Удаление осуществляется оператором delete:
Для обращения к свойствам используется запись «через точку», вида объект.свойство */
delete person.age; //Осталось только свойство name:
document.getElementById('person').innerHTML = person.name;


var person = {
    lastName: 'Иванов',
};
/* Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
Его синтаксис: "prop" in obj, причем имя свойства – в виде строки, например: */
if ('lastName' in person) {
    document.getElementById('lastName').innerHTML = person.lastName;
}
// в JavaScript можно обратиться к любому свойству объекта, даже если его нет. 
// Но если свойство не существует, то вернется специальное значение undefined
document.getElementById('lalala').innerHTML = person.lalala;

/* Мы можем легко проверить существование свойства – получив его и сравнив с undefined:
var person = {
  name: "Василий"
};
alert( person.lalala === undefined ); // true, свойства нет
alert( person.name === undefined ); // false, свойство есть.
*/


/*
Разница между проверками in и === undefined
Есть два средства для проверки наличия свойства в объекте: первое – оператор in, второе – получить его и сравнить с undefined.
Они почти идентичны, но есть одна небольшая разница.
Дело в том, что технически возможно, что свойство есть, а его значением является undefined:

var obj = {};
obj.test = undefined; // добавили свойство со значением undefined

// проверим наличие свойств test и заведомо отсутствующего blabla
alert( obj.test === undefined ); // true
alert( obj.blabla === undefined ); // true

…При этом, как видно из кода, при простом сравнении наличие такого свойства будет неотличимо от его отсутствия.
Но оператор in гарантирует правильный результат:

var obj = {};
obj.test = undefined;

alert( "test" in obj ); // true
alert( "blabla" in obj ); // false

Как правило, в коде мы не будем присваивать undefined, чтобы корректно работали обе проверки. 
А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null.
*/


/* 
Доступ через квадратные скобки
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:

var person = {};
person['name'] = 'Вася'; // то же что и person.name = 'Вася'
// Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:

var person = {};
person['любимый стиль музыки'] = 'Джаз';
//Такое присвоение было бы невозможно «через точку», так интерпретатор после первого пробела подумает, что свойство закончилось, и далее выдаст ошибку:
person.любимый стиль музыки = 'Джаз'; // ??? ошибка
// В обоих случаях, имя свойства обязано быть строкой. Если использовано значение другого типа – JavaScript приведет его к строке автоматически.
*/


person.arrPerson = arr;
var key = 'arrPerson';
document.getElementById('arr').innerHTML =  'Выводим массив случайных чиспел из объекта person: ' + person[key];
/* 
Вообще, если имя свойства хранится в переменной (var key = "arrPerson"), то единственный способ к нему обратиться – это квадратные скобки person[arrPerson].
Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. 
А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.
*/


/*
Объявление со свойствами

var menuSetup = {
  width: 300,
  height: 200,
  title: "Menu"
};
// то
var menuSetup = {};
menuSetup.width = 300;
menuSetup.height = 200;
menuSetup.title = 'Menu';

Названия свойств можно перечислять как в кавычках, так и без, если они удовлетворяют ограничениям для имён переменных.
Например:
var menuSetup = {
  width: 300,
  'height': 200,
  "мама мыла раму": true
};

В качестве значения можно тут же указать и другой объект:
var user = {
  name: "Таня",
  age: 25,
  size: {
    top: 90,
    middle: 60,
    bottom: 90
  }
}
alert(user.name) // "Таня"
alert(user.size.top) // 90
Здесь значением свойства size является объект {top: 90, middle: 60, bottom: 90 }.
*/

/*
Итого
Объекты – это ассоциативные массивы с дополнительными возможностями:

Доступ к элементам осуществляется:
    Напрямую по ключу obj.prop = 5
    Через переменную, в которой хранится ключ:

    var key = "prop";
    obj[key] = 5

Удаление ключей: delete obj.name.
Существование свойства может проверять оператор in: if ("prop" in obj), как правило, работает и просто сравнение if (obj.prop !== undefined).

Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью.
*/


/*
var user = { name: 'Вася' };
var admin = user;
alert(user.name); 
admin.name = 'Петя'; // поменяли данные через admin
alert(user.name); // 'Петя', изменения видны в user
*/


/*
Клонирование объектов
Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.
Примерно так:

var user = {
  name: "Вася",
  age: 30
};

var clone = {}; // новый пустой объект
// скопируем в него все свойства user
for (var key in user) {
  clone[key] = user[key];
}
// теперь clone - полностью независимая копия
clone.name = "Петя"; // поменяли данные в clone
alert( user.name ); // по-прежнему "Вася"

В этом коде каждое свойство объекта user копируется в clone. Если предположить, что они примитивны, 
то каждое скопируется по значению и мы как раз получим полный клон.
Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, 
то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.
*/